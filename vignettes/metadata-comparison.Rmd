---
title: "Metadata Comparison"
author: "Ian Lyttle"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

options(cli.width = 80)
```

```{r setup}
library("steward")
library("conflicted")
library("dplyr")
```

Let's say you have two data frames, and you would like to know how compatible they are. This problem had been floating around in my head for a while, then I saw this [tweet from Sharla Gelfand](https://twitter.com/sharlagelfand/status/1229512910591885317):

> anyone aware of an #rstats package that will compare two data frames' names/types and output nice, descriptive errors if they don't match? do i have to build this myself? - @sharlagelfand

Sharla followed this up with a comprehensive [blog post](https://sharla.party/post/comparing-two-dfs) where she outlines what she wants to be able to do, and how existing solutions address the problem. Happily, Sharla's view of the problem matches perfectly my view of the problem. What's more, Sharla has specified what she wants in a solution, with reprexes! What's not to like?

Here's my proposed solution to the problem, an experimental function called `col_spec_diff()` - it's called this because it's based on the implementation of column-specifications in readr and vroom. 

Following Sharla's lead, when we compare a data frame with itself, we get nothing but success:

```{r identity}
col_spec_compare(iris, iris)
```

This function has two arguments `x` and `y`; these names are used to identify the data frames when there are differences.

For example, we are told if there is a missing column:

```{r missing}
iris_missing_cols <-
  iris %>%
  select(-Sepal.Length)

col_spec_compare(iris_missing_cols, iris)
```

You can see that the "missing" column is identified by name, `Sepal.Length`, then described by a column specification, `col_double()`. We see a second piece of information that tells us that for column names that are common to `x` and `y`, the specifications are identical.

The column specifications are defined in readr (and vroom). If fact, we are using a function in the dev version of readr to determine the column specifications for each of `x` and `y` (building on what the Tidyverse team have already done):

```{r col_spec}
readr::as.col_spec(iris)
```

Resuming the examples, ee are told if there is an extra column:

```{r extra}
iris_extra_cols <-
  iris %>%
  mutate(Specieso = Species)

col_spec_compare(iris_extra_cols, iris)
```

At this point it may be useful to "peek under the hood" a little bit (this article has a larger section on this).

The function `col_spec_compare()` returns an object with S3 class `col_spec_diff`, which is just a way of saying "it's a `list()` with extra functionality". We can use the `str()` function to have a closer look:

```{r str-extra}
diff_extra_cols <- col_spec_compare(iris_extra_cols, iris)

str(diff_extra_cols)
```

This list describes the match between data-frame `x` and data-frame `y`. It has a print method that provides the (hopefully) user-friendly and informative feedback, which is what we are seeing used elsewhere in this article.

```{r}
print(diff_extra_cols)
```

The observant reader will have noticed that `col_spec_compare()` but it does not act on any of its information. It does not throw errors or issue warnings. This is because *I* have no idea what an acceptable match means to you in your situation. Maybe it's OK that there's an extra column, maybe not? I'll talk about this more, later in the article.

Back to the show... what if we have both a missing column and and extra column?

```{r missing-extra}
iris_missing_extra_cols <-
  iris_missing_cols %>%
  mutate(Specieso = Species)

col_spec_compare(iris_missing_extra_cols, iris)
```

Let's say that the columns are ordered differently:

```{r order}
iris_diff_order <-
  iris %>%
  select(Species, everything())

col_spec_compare(iris_diff_order, iris)
```

Or if a column has the same name, but has a different class:

```{r class}
iris_wrong_class <-
  iris %>%
  mutate(Species = as.character(Species))

col_spec_compare(iris_wrong_class, iris)
```

The feedback here focuses on those columns names that are common to both data frames, but have different specifications.

We have a couple more examples - first, Sharla has a "throw the kitchen sink at it" problem:

```{r kitchen-sink}
iris_missing_extra_cols_wrong_class <-
  iris_missing_extra_cols %>%
  mutate(Species = as.character(Species))

col_spec_compare(iris_wrong_class, iris)
```

I offer another example, in the spirit of something I am likely to do:

```{r ian}
col_spec_compare(mtcars, iris)
```

## Under the hood

## Extending this function

